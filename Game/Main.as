package{		import flash.display.MovieClip;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Bitmap;	import flash.display.Shape;	import flash.events.MouseEvent;	import flash.utils.Dictionary;	import flash.geom.Point;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;		public class Main extends MovieClip	{		[Embed(source = "/map.png")] public static const mMapSprite:Class;		private var mMapClip:DisplayObject;		private var mBitmapData:BitmapData;		private var mMapData:Array;		private var mRootNode:QuadTreeNode = null;		private var mObstacleNodesDictionary:Dictionary = new Dictionary();		private var mHidingNodesDictionary:Dictionary = new Dictionary();		private var mUnseenNodesDictionary:Dictionary = new Dictionary();				private var mNumberOfHidingLeft:int = 0;		private var mNumberOfHidingRight:int = 0;		private var mNumberOfHidingTop:int = 0;		private var mNumberOfHidingBottom:int = 0;				private var mStartingNode = null;		private var mStartingPoint:Point;		private var mFinalNode = null;				private var mHelicopter:Helicopter;		private var mTank:Tank;				private var mQuadTreeClip:MovieClip;		private var mHidingPointNodesClip:MovieClip;		private var mPathClip:MovieClip;				public function Main()		{			getMapData();			var heightThreshold:Number = 100;			var densityThreshold:Number = 3;			var maxDepth:Number = 5;						createQuadTree(heightThreshold, densityThreshold, maxDepth);						createHidingPoints(heightThreshold, densityThreshold, maxDepth);						mQuadTreeClip = drawQuadTree(mRootNode);			mQuadTreeClip.name = "quadTree";			stage.addChild(mQuadTreeClip);						mHidingPointNodesClip = drawHidingPointNodes(mHidingNodesDictionary);			mHidingPointNodesClip.name = "hidingPointNodes";			addChild(mHidingPointNodesClip);						stage.addEventListener(MouseEvent.CLICK, onClick);									mTank = new Tank();			mTank.x = 500;			mTank.y = stage.height * 0.2;			stage.addChild(mTank);						mHelicopter = new Helicopter();			mHelicopter.x = 20;			mHelicopter.y = stage.height * 0.5;			stage.addChild(mHelicopter);			mHelicopter.addKeyboardEventListener();						stage.addEventListener(Event.ENTER_FRAME, onEnterFrame);						stage.addEventListener(KeyboardEvent.KEY_UP, onKeyUp);		}				public function onKeyUp(e:KeyboardEvent)		{			if (e.keyCode == Keyboard.Q)			{				if (mQuadTreeClip.alpha == 1)				{					mQuadTreeClip.alpha = 0;				}				else if (mQuadTreeClip.alpha == 0)				{					mQuadTreeClip.alpha = 1;				}			}			if (e.keyCode == Keyboard.W)			{				if (mHidingPointNodesClip.alpha == 1)				{					mHidingPointNodesClip.alpha = 0;				}				else if (mHidingPointNodesClip.alpha == 0)				{					mHidingPointNodesClip.alpha = 1;				}			}		}				private function onEnterFrame(e:Event)		{			mHelicopter.update();			mTank.update2();			mTank.setTankTurretDirection(new Point(mHelicopter.x, mHelicopter.y));						//if (Math.pow(mHelicopter.x - mTank.x, 2) + Math.pow(mHelicopter.y - mTank.y, 2) < 40000)						if(getHitPointBetween(new Point(mHelicopter.x, mHelicopter.y), new Point(mTank.x, mTank.y)) == true ||			   Math.pow(mHelicopter.x - mTank.x, 2) + Math.pow(mHelicopter.y - mTank.y, 2) < 40000)			{				if (mTank.mTargetNode == null)				{					mTank.mTargetNode = getUnseenClosestNode2();					var startingNode = getNode(mRootNode, mTank.x, mTank.y);					var tempPathArray:Array = findPath(startingNode, mTank.mTargetNode);					mTank.mTargetNodePath = smoothPath(tempPathArray, new Point(mTank.x, mTank.y));					//drawNode(mTank.mTargetNode);					trace(mTank.mTargetNode.mX, mTank.mTargetNode.mY, mTank.mTargetNode.mWidth, mTank.mTargetNode.mHeight)					if (stage.getChildByName("pathClip") != null)					{						stage.removeChild(mPathClip);					}					mPathClip = new MovieClip();					mPathClip.name = "pathClip";					for (var tempIndex:int = 1; tempIndex < mTank.mTargetNodePath.length; tempIndex++)					{						var tempCurrentPoint:Point = mTank.mTargetNodePath[tempIndex];						var tempPrevPoint:Point = mTank.mTargetNodePath[tempIndex - 1];						var horizontalLine:Shape = new Shape();						horizontalLine.graphics.lineStyle(2, 0x009900, 1);						horizontalLine.graphics.moveTo(tempPrevPoint.x, tempPrevPoint.y); 						horizontalLine.graphics.lineTo(tempCurrentPoint.x, tempCurrentPoint.y);						mPathClip.addChild(horizontalLine);					}					stage.addChild(mPathClip);				}			}		}				private function getUnseenClosestNode2():QuadTreeNode		{			var tempPossibleNodesArray:Array = new Array();			for (var tempNodeName:String in mHidingNodesDictionary)			{				var tempNode:QuadTreeNode = mHidingNodesDictionary[tempNodeName];				if (tempNode.mHidingOrientation == QuadTreeNode.HO_LEFT &&					mHelicopter.x < tempNode.mX + tempNode.mWidth / 2)				{					//do nothing				}				else if (tempNode.mHidingOrientation == QuadTreeNode.HO_RIGHT &&					mHelicopter.x > tempNode.mX + tempNode.mWidth / 2)				{					//do nothing				}				else if (tempNode.mHidingOrientation == QuadTreeNode.HO_TOP &&					mHelicopter.y < tempNode.mY + tempNode.mHeight / 2)				{					//do nothing				}				else if (tempNode.mHidingOrientation == QuadTreeNode.HO_BOTTOM &&					mHelicopter.y > tempNode.mY + tempNode.mHeight / 2)				{					//do nothing				}				else				{					if ((Math.pow((mTank.x - (tempNode.mX + tempNode.mWidth/2)), 2)) + (Math.pow((mTank.y - (tempNode.mY + tempNode.mHeight/2)), 2)) 						< (Math.pow((mHelicopter.x - (tempNode.mX + tempNode.mWidth/2)), 2)) + (Math.pow((mHelicopter.y - (tempNode.mY + tempNode.mHeight/2)), 2)))					{						tempPossibleNodesArray.push(tempNode);					}				}			}						if (tempPossibleNodesArray.length == 0)			{				for (var tempNodeName:String in mHidingNodesDictionary)				{					return mHidingNodesDictionary[tempNodeName];				}			}			else			{				var randomNodeIndex:int = Math.floor(Math.random() * tempPossibleNodesArray.length)				return tempPossibleNodesArray[randomNodeIndex];			}			return null;		}				private function getUnseenClosestNode():QuadTreeNode		{			var tempTargetNode:QuadTreeNode;			var tempMinimumDistance:int = int.MAX_VALUE;			for (var tempNodeName:String in mHidingNodesDictionary)			{				var tempNode:QuadTreeNode = mHidingNodesDictionary[tempNodeName];				if (tempNode.mHidingOrientation == QuadTreeNode.HO_LEFT &&					mHelicopter.x < tempNode.mX + tempNode.mWidth / 2)				{					//do nothing				}				else if (tempNode.mHidingOrientation == QuadTreeNode.HO_RIGHT &&					mHelicopter.x > tempNode.mX + tempNode.mWidth / 2)				{					//do nothing				}				else if (tempNode.mHidingOrientation == QuadTreeNode.HO_TOP &&					mHelicopter.y < tempNode.mY + tempNode.mHeight / 2)				{					//do nothing				}				else if (tempNode.mHidingOrientation == QuadTreeNode.HO_BOTTOM &&					mHelicopter.y > tempNode.mY + tempNode.mHeight / 2)				{					//do nothing				}				else				{					if (getHitPointBetween(new Point(mHelicopter.x, mHelicopter.y), new Point(tempNode.mX + tempNode.mWidth / 2, tempNode.mY + tempNode.mHeight / 2)) == false)					{						if (Math.pow(tempNode.mX + tempNode.mWidth / 2 - mTank.x, 2) + Math.pow(tempNode.mY + tempNode.mHeight / 2 - mTank.y, 2) < tempMinimumDistance)						{							if ((Math.pow(tempNode.mX + tempNode.mWidth / 2 - mHelicopter.x, 2) + Math.pow(tempNode.mY + tempNode.mHeight / 2 - mHelicopter.y, 2)) -								(Math.pow(tempNode.mX + tempNode.mWidth / 2 - mTank.x, 2) + Math.pow(tempNode.mY + tempNode.mHeight / 2 - mTank.y, 2)) >								(Math.pow(mHelicopter.x - mTank.x, 2) + Math.pow(mHelicopter.y - mTank.y, 2)))							tempTargetNode = tempNode;							tempMinimumDistance = Math.pow(tempNode.mX + tempNode.mWidth / 2 - mTank.x, 2) + Math.pow(tempNode.mY + tempNode.mHeight / 2 - mTank.y, 2);						}					}				}			}			return tempTargetNode;		}				private function drawQuadTree(rootNode:QuadTreeNode):MovieClip		{			if (getChildByName("quadTreeClip") != null)			{				removeChild(getChildByName("quadTreeClip"));			}			var tempQuadTreeClip:MovieClip = new MovieClip();			tempQuadTreeClip.name = "quadTreeClip";			drawQuadTreeRecursively(rootNode, tempQuadTreeClip);			return tempQuadTreeClip;		}				private function drawQuadTreeRecursively(currentNode:QuadTreeNode, quadTreeClip:MovieClip)		{			if (currentNode.mTL != null)			{				// draw lines				var verticalLine:Shape = new Shape();				verticalLine.graphics.lineStyle(1, 0xFF0000, 1);				verticalLine.graphics.moveTo(currentNode.mX + currentNode.mWidth / 2, currentNode.mY);				verticalLine.graphics.lineTo(currentNode.mX + currentNode.mWidth / 2, currentNode.mY + currentNode.mHeight);				quadTreeClip.addChild(verticalLine);				var horizontalLine:Shape = new Shape();  				horizontalLine.graphics.lineStyle(1, 0xFF0000, 1);				horizontalLine.graphics.moveTo(currentNode.mX, currentNode.mY + currentNode.mHeight / 2); 				horizontalLine.graphics.lineTo(currentNode.mX + currentNode.mWidth, currentNode.mY + currentNode.mHeight / 2);				quadTreeClip.addChild(horizontalLine);								drawQuadTreeRecursively(currentNode.mTL, quadTreeClip);				drawQuadTreeRecursively(currentNode.mTR, quadTreeClip);				drawQuadTreeRecursively(currentNode.mBL, quadTreeClip);				drawQuadTreeRecursively(currentNode.mBR, quadTreeClip);			}			else			{				if (currentNode.mValue == 1)				{					var rectangle:Shape = new Shape();					rectangle.graphics.beginFill(0x0000FF);					rectangle.graphics.drawRect(currentNode.mX, currentNode.mY, currentNode.mWidth, currentNode.mHeight);					rectangle.graphics.endFill();					rectangle.alpha = 0.5;					quadTreeClip.addChild(rectangle);				}			}		}				private function getMapData()		{			mMapClip = new mMapSprite() as DisplayObject;						if (mMapClip != null)			{				mBitmapData = new BitmapData(mMapClip.width, mMapClip.height, true, 0x00000000);				mBitmapData.draw(mMapClip);				var bitmap1:Bitmap = new Bitmap(mBitmapData);				addChild(bitmap1);								mMapData = new Array();				for (var row:int = 0; row < mMapClip.height; row++)				{					var tempMapRowData:Array = new Array();					for (var column:int = 0; column < mMapClip.width; column++)					{						var colorInt:uint = mBitmapData.getPixel(column, row);						var rValue:int = colorInt / (256 * 256);						var gValue:int = (colorInt % (256 * 256)) / 256;						var bValue:int = colorInt % 256;						var grayScaleValue:int = 0.299 * rValue + 0.587 * gValue + 0.114 * bValue;						tempMapRowData.push(grayScaleValue);					}					mMapData.push(tempMapRowData);				}			}			else			{				var err = new Error("map.png is missing!");				trace(err.toString());			}		}				private function createQuadTree(heightThreshold:int, densityThreshold:int, maxDepth:int)		{			mRootNode = new QuadTreeNode();			mRootNode.mParent = null;			checkQuadTreeNode(0, 0, mMapData[0].length, mMapData.length, heightThreshold, densityThreshold, maxDepth, 0, mRootNode);		}				private function checkQuadTreeNode(nodeX:int, nodeY:int, nodeWidth:Number, nodeHeight:Number, heightThreshold:int, densityThreshold:int, maxDepth:int, currentDepth:int, node:QuadTreeNode)		{			node.mX = nodeX;			node.mY = nodeY;			node.mWidth = nodeWidth;			node.mHeight = nodeHeight;			node.setName();						var tempObstacleRatio:Number = getRatioOfObstaclePixels(nodeX, nodeY, nodeWidth, nodeHeight, heightThreshold);						if (tempObstacleRatio < densityThreshold)			{				node.mDepth = currentDepth;				node.mValue = 0;			}			else if (tempObstacleRatio > 100 - densityThreshold)			{				node.mDepth = currentDepth;				node.mValue = 1;				mObstacleNodesDictionary[node.mName] = node;			}			else			{				if (currentDepth > maxDepth)				{					node.mDepth = currentDepth;					node.mValue = 1;					mObstacleNodesDictionary[node.mName] = node;					return;				}								node.mTL = new QuadTreeNode();				node.mTL.mParent = node;				node.mTL.mOrientation = QuadTreeNode.O_TL;				checkQuadTreeNode(nodeX, nodeY, nodeWidth / 2, nodeHeight / 2, heightThreshold, densityThreshold, maxDepth, currentDepth + 1, node.mTL);				node.mTR = new QuadTreeNode();				node.mTR.mParent = node;				node.mTR.mOrientation = QuadTreeNode.O_TR;				checkQuadTreeNode(nodeX + nodeWidth / 2, nodeY, nodeWidth / 2, nodeHeight / 2, heightThreshold, densityThreshold, maxDepth, currentDepth + 1, node.mTR);				node.mBL = new QuadTreeNode();				node.mBL.mParent = node;				node.mBL.mOrientation = QuadTreeNode.O_BL;				checkQuadTreeNode(nodeX, nodeY + nodeHeight / 2, nodeWidth / 2, nodeHeight / 2, heightThreshold, densityThreshold, maxDepth, currentDepth + 1, node.mBL);				node.mBR = new QuadTreeNode();				node.mBR.mParent = node;				node.mBR.mOrientation = QuadTreeNode.O_BR;				checkQuadTreeNode(nodeX + nodeWidth / 2, nodeY + nodeHeight / 2, nodeWidth / 2, nodeHeight / 2, heightThreshold, densityThreshold, maxDepth, currentDepth + 1, node.mBR);			}		}				private function getRatioOfObstaclePixels(nodeX:int, nodeY:int, nodeWidth:Number, nodeHeight:Number, heightThreshold:int):Number		{			var numberOfObstaclePixels:int = 0;			var numberOfNonObstaclePixels:int = 0;			for (var column:int = nodeX; column < nodeX + nodeWidth; column++)			{				for (var row:int = nodeY; row < nodeY + nodeHeight; row++)				{					if (mMapData[row][column] < heightThreshold)					{						numberOfObstaclePixels++;					}					else					{						numberOfNonObstaclePixels++;					}				}			}			return (numberOfObstaclePixels / (numberOfNonObstaclePixels + numberOfObstaclePixels)) * 100;		}				private function createHidingPoints(heightThreshold:int, densityThreshold:int, maxDepth:int)		{			var tempAdjacentNodeDictionary:Dictionary;			while(true)			{				tempAdjacentNodeDictionary = new Dictionary();				for (var tempNodeName:String in mObstacleNodesDictionary)				{					var tempNode:QuadTreeNode = mObstacleNodesDictionary[tempNodeName];					var tempAdjacentNodeSubDictionary = findAdjacentNodes(tempNode, new Dictionary());					for (var tempNodeName:String in tempAdjacentNodeSubDictionary)					{						var tempNode:QuadTreeNode = tempAdjacentNodeSubDictionary[tempNodeName];						tempAdjacentNodeDictionary[tempNode.mName] = tempNode;					}				}				for (var tempNodeName:String in tempAdjacentNodeDictionary)				{					var tempNode:QuadTreeNode = tempAdjacentNodeDictionary[tempNodeName];					if (tempNode.mValue == 1)					{						delete tempAdjacentNodeDictionary[tempNodeName];					}				}				var numberOfBigNodes:int = 0;				for (var tempNodeName:String in tempAdjacentNodeDictionary)				{					var tempNode:QuadTreeNode = tempAdjacentNodeDictionary[tempNodeName];					if (tempNode.mDepth <= maxDepth)					{						numberOfBigNodes++;						tempNode.mTL = new QuadTreeNode();						tempNode.mTL.mParent = tempNode;						tempNode.mTL.mOrientation = QuadTreeNode.O_TL;						tempNode.mTL.mDepth = tempNode.mDepth + 1;						tempNode.mTL.mX = tempNode.mX;						tempNode.mTL.mY = tempNode.mY;						tempNode.mTL.mWidth = tempNode.mWidth / 2;						tempNode.mTL.mHeight = tempNode.mHeight / 2;						tempNode.mTL.setName();						var tempObstacleRatio:Number = getRatioOfObstaclePixels(tempNode.mTL.mX, tempNode.mTL.mY, tempNode.mTL.mWidth, tempNode.mTL.mHeight, heightThreshold);						if (tempObstacleRatio < densityThreshold)						{							tempNode.mTL.mValue = 0;						}						else if (tempObstacleRatio > 100 - densityThreshold)						{							tempNode.mTL.mValue = 1;							mObstacleNodesDictionary[tempNode.mTL.mName] = tempNode.mTL;						}						else						{							if (tempNode.mTL.mDepth > maxDepth)							{								tempNode.mTL.mValue = 1;								mObstacleNodesDictionary[tempNode.mTL.mName] = tempNode.mTL;							}						}												tempNode.mTR = new QuadTreeNode();						tempNode.mTR.mParent = tempNode;						tempNode.mTR.mOrientation = QuadTreeNode.O_TR;						tempNode.mTR.mDepth = tempNode.mDepth + 1;						tempNode.mTR.mValue = 0;						tempNode.mTR.mX = tempNode.mX + tempNode.mWidth / 2;						tempNode.mTR.mY = tempNode.mY;						tempNode.mTR.mWidth = tempNode.mWidth / 2;						tempNode.mTR.mHeight = tempNode.mHeight / 2;						tempNode.mTR.setName();						var tempObstacleRatio:Number = getRatioOfObstaclePixels(tempNode.mTR.mX, tempNode.mTR.mY, tempNode.mTR.mWidth, tempNode.mTR.mHeight, heightThreshold);						if (tempObstacleRatio < densityThreshold)						{							tempNode.mTR.mValue = 0;						}						else if (tempObstacleRatio > 100 - densityThreshold)						{							tempNode.mTR.mValue = 1;							mObstacleNodesDictionary[tempNode.mTR.mName] = tempNode.mTR;						}						else						{							if (tempNode.mTR.mDepth > maxDepth)							{								tempNode.mTR.mValue = 1;								mObstacleNodesDictionary[tempNode.mTR.mName] = tempNode.mTR;							}						}												tempNode.mBL = new QuadTreeNode();						tempNode.mBL.mParent = tempNode;						tempNode.mBL.mOrientation = QuadTreeNode.O_BL;						tempNode.mBL.mDepth = tempNode.mDepth + 1;						tempNode.mBL.mValue = 0;						tempNode.mBL.mX = tempNode.mX;						tempNode.mBL.mY = tempNode.mY + tempNode.mHeight / 2;						tempNode.mBL.mWidth = tempNode.mWidth / 2;						tempNode.mBL.mHeight = tempNode.mHeight / 2;						tempNode.mBL.setName();						var tempObstacleRatio:Number = getRatioOfObstaclePixels(tempNode.mBL.mX, tempNode.mBL.mY, tempNode.mBL.mWidth, tempNode.mBL.mHeight, heightThreshold);						if (tempObstacleRatio < densityThreshold)						{							tempNode.mBL.mValue = 0;						}						else if (tempObstacleRatio > 100 - densityThreshold)						{							tempNode.mBL.mValue = 1;							mObstacleNodesDictionary[tempNode.mBL.mName] = tempNode.mBL;						}						else						{							if (tempNode.mBL.mDepth > maxDepth)							{								tempNode.mBL.mValue = 1;								mObstacleNodesDictionary[tempNode.mBL.mName] = tempNode.mBL;							}						}												tempNode.mBR = new QuadTreeNode();						tempNode.mBR.mParent = tempNode;						tempNode.mBR.mOrientation = QuadTreeNode.O_BR;						tempNode.mBR.mDepth = tempNode.mDepth + 1;						tempNode.mBR.mValue = 0;						tempNode.mBR.mX = tempNode.mX + tempNode.mWidth / 2;						tempNode.mBR.mY = tempNode.mY + tempNode.mHeight / 2;						tempNode.mBR.mWidth = tempNode.mWidth / 2;						tempNode.mBR.mHeight = tempNode.mHeight / 2;						tempNode.mBR.setName();						var tempObstacleRatio:Number = getRatioOfObstaclePixels(tempNode.mBR.mX, tempNode.mBR.mY, tempNode.mBR.mWidth, tempNode.mBR.mHeight, heightThreshold);						if (tempObstacleRatio < densityThreshold)						{							tempNode.mBR.mValue = 0;						}						else if (tempObstacleRatio > 100 - densityThreshold)						{							tempNode.mBR.mValue = 1;							mObstacleNodesDictionary[tempNode.mBR.mName] = tempNode.mBR;						}						else						{							if (tempNode.mBR.mDepth > maxDepth)							{								tempNode.mBR.mValue = 1;								mObstacleNodesDictionary[tempNode.mBR.mName] = tempNode.mBR;							}						}					}				}				if (numberOfBigNodes == 0)				{					break;				}			}			mHidingNodesDictionary = tempAdjacentNodeDictionary;		}				private function onClick(e:MouseEvent)		{			if (mStartingNode == null)			{				mStartingPoint = new Point(e.target.mouseX, e.target.mouseY);				mStartingNode = getNode(mRootNode, e.target.mouseX, e.target.mouseY);			}			else if (mFinalNode == null)			{				var pathClip:MovieClip = new MovieClip();				pathClip.name = "path";				if (getChildByName("path") != null)				{					removeChild(getChildByName("path"));				}								mFinalNode = getNode(mRootNode, e.target.mouseX, e.target.mouseY);				var tempPathArray:Array = findPath(mStartingNode, mFinalNode);				var tempSmoothedPathArray:Array = smoothPath(tempPathArray, mStartingPoint);				for (var tempIndex:int = 1; tempIndex < tempPathArray.length; tempIndex++)				{					var tempCurrentNode:QuadTreeNode = (tempPathArray[tempIndex] as QuadTreeNode);					var tempPrevNode:QuadTreeNode = (tempPathArray[tempIndex - 1] as QuadTreeNode);					var horizontalLine:Shape = new Shape();  					horizontalLine.graphics.lineStyle(2, 0x440044, 1);					horizontalLine.graphics.moveTo(tempPrevNode.mX + tempPrevNode.mWidth / 2, tempPrevNode.mY + tempPrevNode.mHeight / 2); 					horizontalLine.graphics.lineTo(tempCurrentNode.mX + tempCurrentNode.mWidth / 2, tempCurrentNode.mY + tempCurrentNode.mHeight / 2);					pathClip.addChild(horizontalLine);				}								for (var tempIndex:int = 1; tempIndex < tempSmoothedPathArray.length; tempIndex++)				{					/*var tempCurrentNode:QuadTreeNode = (tempSmoothedPathArray[tempIndex] as QuadTreeNode);					var tempPrevNode:QuadTreeNode = (tempSmoothedPathArray[tempIndex - 1] as QuadTreeNode);					var horizontalLine:Shape = new Shape();  					horizontalLine.graphics.lineStyle(2, 0x009900, 1);					horizontalLine.graphics.moveTo(tempPrevNode.mX + tempPrevNode.mWidth / 2, tempPrevNode.mY + tempPrevNode.mHeight / 2); 					horizontalLine.graphics.lineTo(tempCurrentNode.mX + tempCurrentNode.mWidth / 2, tempCurrentNode.mY + tempCurrentNode.mHeight / 2);					pathClip.addChild(horizontalLine);*/					var tempCurrentPoint:Point = tempSmoothedPathArray[tempIndex];					var tempPrevPoint:Point = tempSmoothedPathArray[tempIndex - 1];					var horizontalLine:Shape = new Shape();  					horizontalLine.graphics.lineStyle(2, 0x009900, 1);					horizontalLine.graphics.moveTo(tempPrevPoint.x, tempPrevPoint.y); 					horizontalLine.graphics.lineTo(tempCurrentPoint.x, tempCurrentPoint.y);					pathClip.addChild(horizontalLine);				}								addChild(pathClip);			}			else			{				mStartingPoint = new Point(0,0);				mStartingNode = null;				mFinalNode = null;				mStartingNode = getNode(mRootNode, e.target.mouseX, e.target.mouseY);				mStartingPoint = new Point(e.target.mouseX, e.target.mouseY);			}		}				private function findPath(startingNode:QuadTreeNode, finalNode:QuadTreeNode):Array		{			var tempQueue:Array = new Array();			var tempQueueItem:Array = new Array();			// item 0 -> distance + heuristic			tempQueueItem[0] = 0 + distanceBetween(startingNode, finalNode);			// item 1 -> node itself			tempQueueItem[1] = startingNode;			// item 2 -> path			var tempQueuePathList:Array = new Array();			tempQueuePathList.push(startingNode);			tempQueueItem[2] = tempQueuePathList;						tempQueue.push(tempQueueItem);			// start checking			var tempCheckList:Dictionary = new Dictionary();			for (;;)			{				// get the closest node				var minimumDistance:Number = int.MAX_VALUE;				var minimumIndex:int = 0;				for (var index:int = 0; index < tempQueue.length; index++)				{					var tempItem:Array = tempQueue[index];					if (tempItem[0] < minimumDistance)					{						minimumDistance = tempItem[0];						minimumIndex = index;					}				}								var closestItem:Array = tempQueue[minimumIndex];								tempQueue.splice(minimumIndex, 1);								if (closestItem[1] == finalNode)				{					tempCheckList = new Dictionary();					return closestItem[2];				}				else				{					tempCheckList[closestItem[1].mName] = closestItem[1];										var tempAdjacentNodes:Dictionary = findAdjacentNodes(closestItem[1], new Dictionary());										for (var tempAdjacentNodeName:String in tempAdjacentNodes)					{						var tempAdjacentNode:QuadTreeNode = tempAdjacentNodes[tempAdjacentNodeName];						if (tempAdjacentNode.mValue == 0 && tempCheckList[tempAdjacentNode.mName] == null)						{							var queueItem:Array = new Array();							// item 0 -> distance + heuristic							queueItem[0] = distanceBetween(tempAdjacentNode, closestItem[1]) + distanceBetween(tempAdjacentNode, finalNode);							// item 1 -> node itself							queueItem[1] = tempAdjacentNode;							// item 2 -> path							var tempQueuePathList:Array = new Array();							for (var tempIndex:int = 0; tempIndex < closestItem[2].length; tempIndex++)							{								tempQueuePathList.push(closestItem[2][tempIndex]);							}							tempQueuePathList.push(tempAdjacentNode);							queueItem[2] = tempQueuePathList;							tempQueue.push(queueItem);						}					}				}			}			return new Array();		}				private function smoothPath(currentPath:Array, clickPoint:Point):Array		{			// node representation			/*var finalNodeArray:Array = new Array();			finalNodeArray.push(currentPath[0]);			var tempStartingIndex = 0;			var startingPoint:Point = new Point(currentPath[tempStartingIndex].mX + currentPath[tempStartingIndex].mWidth/2, currentPath[tempStartingIndex].mY + currentPath[tempStartingIndex].mHeight/2);			for (var tempIndex:int = 1; tempIndex < currentPath.length; tempIndex++)			{				var nextPoint:Point = new Point();				var tempNodesArray:Array = new Array();				var isAvailable:Boolean = true;				if (tempIndex - tempStartingIndex > 1)				{					nextPoint = new Point(currentPath[tempIndex].mX + currentPath[tempIndex].mWidth/2, currentPath[tempIndex].mY + currentPath[tempIndex].mHeight/2);					isAvailable = getHitPointBetween(startingPoint, nextPoint);				}								if (isAvailable == false)				{					finalNodeArray.push(currentPath[tempIndex -1]);					tempStartingIndex = tempIndex - 1;					startingPoint = new Point(currentPath[tempStartingIndex].mX + currentPath[tempStartingIndex].mWidth/2, currentPath[tempStartingIndex].mY + currentPath[tempStartingIndex].mHeight/2);					if (tempIndex == currentPath.length - 1)					{						finalNodeArray.push(currentPath[tempIndex]);					}				}				else				{					if (tempIndex == currentPath.length - 1)					{						finalNodeArray.push(currentPath[tempIndex]);					}				}			}			return finalNodeArray;*/						//point representation			var finalNodeArray:Array = new Array();			finalNodeArray.push(clickPoint);			var tempStartingIndex = 0;			var startingPoint:Point = clickPoint;			for (var tempIndex:int = 1; tempIndex < currentPath.length; tempIndex++)			{				var nextPoint:Point = new Point();				var tempNodesArray:Array = new Array();				var isAvailable:Boolean = true;				if (tempIndex - tempStartingIndex > 1)				{					nextPoint = new Point(currentPath[tempIndex].mX + currentPath[tempIndex].mWidth/2, currentPath[tempIndex].mY + currentPath[tempIndex].mHeight/2);					isAvailable = getHitPointBetween(startingPoint, nextPoint);				}								if (isAvailable == false)				{					finalNodeArray.push(new Point(currentPath[tempIndex-1].mX + currentPath[tempIndex-1].mWidth / 2, currentPath[tempIndex-1].mY + currentPath[tempIndex-1].mHeight / 2));					tempStartingIndex = tempIndex - 1;					startingPoint = new Point(currentPath[tempStartingIndex].mX + currentPath[tempStartingIndex].mWidth/2, currentPath[tempStartingIndex].mY + currentPath[tempStartingIndex].mHeight/2);					if (tempIndex == currentPath.length - 1)					{						finalNodeArray.push(new Point(currentPath[tempIndex].mX + currentPath[tempIndex].mWidth / 2, currentPath[tempIndex].mY + currentPath[tempIndex].mHeight / 2));					}				}				else				{					if (tempIndex == currentPath.length - 1)					{						finalNodeArray.push(new Point(currentPath[tempIndex].mX + currentPath[tempIndex].mWidth / 2, currentPath[tempIndex].mY + currentPath[tempIndex].mHeight / 2));					}				}			}			return finalNodeArray;		}				private function getHitPointBetween(startingPoint:Point, nextPoint:Point):Boolean		{			var currentPoint:Point = new Point();						var tempDistance:Number = startingPoint.subtract(nextPoint).length;			var numberOfIterations:int = Math.floor(tempDistance / 5);			for (var tempIndex:int = 0; tempIndex < numberOfIterations; tempIndex++)			{				var tempSubstraction:Point = startingPoint.subtract(nextPoint);				//trace(startingPoint.x, startingPoint.y, nextPoint.x, nextPoint.y, tempSubstraction.x, tempSubstraction.y);				currentPoint = startingPoint.subtract(new Point(tempSubstraction.x * tempIndex / numberOfIterations, tempSubstraction.y * tempIndex / numberOfIterations));				//trace(currentPoint.x, currentPoint.y);				if (getNode(mRootNode, currentPoint.x, currentPoint.y).mValue == 1)				{					return false;				}			}			return true;		}				private function distanceBetween(startingNode:QuadTreeNode, finalNode:QuadTreeNode):Number		{			var tempStartingNodeCenter:Point = new Point(startingNode.mX + startingNode.mWidth / 2, startingNode.mY + startingNode.mHeight / 2);			var tempFinalNodeCenter:Point = new Point(finalNode.mX + finalNode.mWidth / 2, finalNode.mY + finalNode.mHeight / 2);			return Math.sqrt(Math.pow(tempStartingNodeCenter.x - tempFinalNodeCenter.x, 2) + Math.pow(tempStartingNodeCenter.y - tempFinalNodeCenter.y, 2));		}				private function getNode(currentNode:QuadTreeNode, xPos:int, yPos:int):QuadTreeNode		{			if (currentNode.mTL == null)			{				// found				//drawNode(currentNode);				var tempAdjacentNodeDictionary:Dictionary = findAdjacentNodes(currentNode, new Dictionary());								//drawNodeDictionary(tempAdjacentNodeDictionary);								return currentNode;			}			else			{				if (xPos >= currentNode.mX && xPos <= currentNode.mX + currentNode.mWidth / 2 &&					yPos >= currentNode.mY && yPos <= currentNode.mY + currentNode.mHeight / 2)				{					return getNode(currentNode.mTL, xPos, yPos);				}				else if (xPos >= currentNode.mX + currentNode.mWidth / 2 && xPos <= currentNode.mX + currentNode.mWidth &&					yPos >= currentNode.mY && yPos <= currentNode.mY + currentNode.mHeight / 2)				{					return getNode(currentNode.mTR, xPos, yPos);				}				else if (xPos >= currentNode.mX && xPos <= currentNode.mX + currentNode.mWidth / 2 &&					yPos >= currentNode.mY + currentNode.mHeight / 2 && yPos <= currentNode.mY + currentNode.mHeight)				{					return getNode(currentNode.mBL, xPos, yPos);				}				else if (xPos >= currentNode.mX + currentNode.mWidth / 2 && xPos <= currentNode.mX + currentNode.mWidth &&					yPos >= currentNode.mY + currentNode.mHeight / 2 && yPos <= currentNode.mY + currentNode.mHeight)				{					return getNode(currentNode.mBR, xPos, yPos);				}			}			return null;		}				private function findAdjacentNodes(node:QuadTreeNode, nodeDictionary:Dictionary):Dictionary		{			if (node.mOrientation == QuadTreeNode.O_TL)			{				findLeftMostNodes(node.mParent.mTR, nodeDictionary);				findTopMostNodes(node.mParent.mBL, nodeDictionary);								var tempNodeTypeArray:Array = new Array();				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_BL )				{					tempNodeTypeArray.push(QuadTreeNode.O_BL);				}				else if (node.mOrientation == QuadTreeNode.O_TR ||						 node.mOrientation == QuadTreeNode.O_BR)				{					tempNodeTypeArray.push(QuadTreeNode.O_BR);				}				findTopAdjacentNode(node.mParent, nodeDictionary, tempNodeTypeArray);								tempNodeTypeArray = new Array();				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_TR )				{					tempNodeTypeArray.push(QuadTreeNode.O_TR);				}				else if (node.mOrientation == QuadTreeNode.O_BL ||						 node.mOrientation == QuadTreeNode.O_BR)				{					tempNodeTypeArray.push(QuadTreeNode.O_BR);				}				findLeftAdjacentNode(node.mParent, nodeDictionary, tempNodeTypeArray);			}			else if (node.mOrientation == QuadTreeNode.O_TR)			{				findRightMostNodes(node.mParent.mTL, nodeDictionary);				findTopMostNodes(node.mParent.mBR, nodeDictionary);								var tempNodeTypeArray:Array = new Array();				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_BL )				{					tempNodeTypeArray.push(QuadTreeNode.O_BL);				}				else if (node.mOrientation == QuadTreeNode.O_TR ||						 node.mOrientation == QuadTreeNode.O_BR)				{					tempNodeTypeArray.push(QuadTreeNode.O_BR);				}				findTopAdjacentNode(node.mParent, nodeDictionary, tempNodeTypeArray);								tempNodeTypeArray = new Array();				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_TR )				{					tempNodeTypeArray.push(QuadTreeNode.O_TL);				}				else if (node.mOrientation == QuadTreeNode.O_BL ||						 node.mOrientation == QuadTreeNode.O_BR)				{					tempNodeTypeArray.push(QuadTreeNode.O_BL);				}				findRightAdjacentNode(node.mParent, nodeDictionary, tempNodeTypeArray);			}			else if (node.mOrientation == QuadTreeNode.O_BL)			{				findBottomMostNodes(node.mParent.mTL, nodeDictionary);				findLeftMostNodes(node.mParent.mBR, nodeDictionary);								var tempNodeTypeArray:Array = new Array();				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_BL )				{					tempNodeTypeArray.push(QuadTreeNode.O_TL);				}				else if (node.mOrientation == QuadTreeNode.O_TR ||						 node.mOrientation == QuadTreeNode.O_BR)				{					tempNodeTypeArray.push(QuadTreeNode.O_TR);				}				findBottomAdjacentNode(node.mParent, nodeDictionary, tempNodeTypeArray);								tempNodeTypeArray = new Array();				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_TR )				{					tempNodeTypeArray.push(QuadTreeNode.O_TR);				}				else if (node.mOrientation == QuadTreeNode.O_BL ||						 node.mOrientation == QuadTreeNode.O_BR)				{					tempNodeTypeArray.push(QuadTreeNode.O_BR);				}				findLeftAdjacentNode(node.mParent, nodeDictionary, tempNodeTypeArray);			}			else if (node.mOrientation == QuadTreeNode.O_BR)			{				findBottomMostNodes(node.mParent.mTR, nodeDictionary);				findRightMostNodes(node.mParent.mBL, nodeDictionary);								var tempNodeTypeArray:Array = new Array();				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_BL )				{					tempNodeTypeArray.push(QuadTreeNode.O_TL);				}				else if (node.mOrientation == QuadTreeNode.O_TR ||						 node.mOrientation == QuadTreeNode.O_BR)				{					tempNodeTypeArray.push(QuadTreeNode.O_TR);				}				findBottomAdjacentNode(node.mParent, nodeDictionary, tempNodeTypeArray);								tempNodeTypeArray = new Array();				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_TR )				{					tempNodeTypeArray.push(QuadTreeNode.O_TL);				}				else if (node.mOrientation == QuadTreeNode.O_BL ||						 node.mOrientation == QuadTreeNode.O_BR)				{					tempNodeTypeArray.push(QuadTreeNode.O_BL);				}				findRightAdjacentNode(node.mParent, nodeDictionary, tempNodeTypeArray);			}			return nodeDictionary;		}				private function findLeftMostNodes(node:QuadTreeNode, nodeDictionary:Dictionary)		{			if (node == null)			{				return;			}			if (node.mTL == null)			{				if (node.mHidingOrientation == QuadTreeNode.HO_NONE)				{					node.mHidingOrientation = QuadTreeNode.HO_RIGHT;					mNumberOfHidingRight++;				}				nodeDictionary[node.mName] = node;			}			else			{				findLeftMostNodes(node.mTL, nodeDictionary);				findLeftMostNodes(node.mBL, nodeDictionary);			}		}				private function findRightMostNodes(node:QuadTreeNode, nodeDictionary:Dictionary)		{			if (node == null)			{				return;			}			if (node.mTL == null)			{				if (node.mHidingOrientation == QuadTreeNode.HO_NONE)				{					node.mHidingOrientation = QuadTreeNode.HO_LEFT;					mNumberOfHidingLeft++;				}				nodeDictionary[node.mName] = node;			}			else			{				findRightMostNodes(node.mTR, nodeDictionary);				findRightMostNodes(node.mBR, nodeDictionary);			}		}				private function findTopMostNodes(node:QuadTreeNode, nodeDictionary:Dictionary)		{			if (node == null)			{				return;			}			if (node.mTL == null)			{				if (node.mHidingOrientation == QuadTreeNode.HO_NONE)				{					node.mHidingOrientation = QuadTreeNode.HO_BOTTOM;					mNumberOfHidingBottom++;				}				nodeDictionary[node.mName] = node;			}			else			{				findTopMostNodes(node.mTL, nodeDictionary);				findTopMostNodes(node.mTR, nodeDictionary);			}		}				private function findBottomMostNodes(node:QuadTreeNode, nodeDictionary:Dictionary)		{			if (node == null)			{				return;			}			if (node.mTL == null)			{				if (node.mHidingOrientation == QuadTreeNode.HO_NONE)				{					node.mHidingOrientation = QuadTreeNode.HO_TOP;					mNumberOfHidingTop++;				}				nodeDictionary[node.mName] = node;			}			else			{				findBottomMostNodes(node.mBL, nodeDictionary);				findBottomMostNodes(node.mBR, nodeDictionary);			}		}				private function findLeftAdjacentNode(node:QuadTreeNode, nodeDictionary:Dictionary, nodeTypeArray:Array)		{			if (node.mOrientation == QuadTreeNode.O_TR)			{				if (node.mParent != null)				{					var tempCurrentNode:QuadTreeNode = node.mParent.mTL;					for (var index:int = nodeTypeArray.length-1; index >= 0; index--)					{						if (tempCurrentNode.mTL == null)						{							findRightMostNodes(tempCurrentNode, nodeDictionary);							return;						}						if (nodeTypeArray[index] == QuadTreeNode.O_TL)						{							tempCurrentNode = tempCurrentNode.mTL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_TR)						{							tempCurrentNode = tempCurrentNode.mTR;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BL)						{							tempCurrentNode = tempCurrentNode.mBL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BR)						{							tempCurrentNode = tempCurrentNode.mBR;						}					}					findRightMostNodes(tempCurrentNode, nodeDictionary);				}			}			else if (node.mOrientation == QuadTreeNode.O_BR)			{				if (node.mParent != null)				{					var tempCurrentNode:QuadTreeNode = node.mParent.mBL;					for (var index:int = nodeTypeArray.length-1; index >= 0; index--)					{						if (tempCurrentNode.mTL == null)						{							findRightMostNodes(tempCurrentNode, nodeDictionary);							return;						}						if (nodeTypeArray[index] == QuadTreeNode.O_TL)						{							tempCurrentNode = tempCurrentNode.mTL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_TR)						{							tempCurrentNode = tempCurrentNode.mTR;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BL)						{							tempCurrentNode = tempCurrentNode.mBL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BR)						{							tempCurrentNode = tempCurrentNode.mBR;						}					}					findRightMostNodes(tempCurrentNode, nodeDictionary);				}			}			else			{				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_TR )				{					nodeTypeArray.push(QuadTreeNode.O_TR);				}				else if (node.mOrientation == QuadTreeNode.O_BL ||						 node.mOrientation == QuadTreeNode.O_BR)				{					nodeTypeArray.push(QuadTreeNode.O_BR);				}				if (node.mParent != null)				{					findLeftAdjacentNode(node.mParent, nodeDictionary, nodeTypeArray);				}			}		}				private function findRightAdjacentNode(node:QuadTreeNode, nodeDictionary:Dictionary, nodeTypeArray:Array)		{			if (node.mOrientation == QuadTreeNode.O_TL)			{				if (node.mParent != null)				{					var tempCurrentNode:QuadTreeNode = node.mParent.mTR;					for (var index:int = nodeTypeArray.length-1; index >= 0; index--)					{						if (tempCurrentNode.mTL == null)						{							findLeftMostNodes(tempCurrentNode, nodeDictionary);							return;						}						if (nodeTypeArray[index] == QuadTreeNode.O_TL)						{							tempCurrentNode = tempCurrentNode.mTL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_TR)						{							tempCurrentNode = tempCurrentNode.mTR;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BL)						{							tempCurrentNode = tempCurrentNode.mBL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BR)						{							tempCurrentNode = tempCurrentNode.mBR;						}					}					findLeftMostNodes(tempCurrentNode, nodeDictionary);				}			}			else if (node.mOrientation == QuadTreeNode.O_BL)			{				if (node.mParent != null)				{					var tempCurrentNode:QuadTreeNode = node.mParent.mBR;					for (var index:int = nodeTypeArray.length-1; index >= 0; index--)					{						if (tempCurrentNode.mTL == null)						{							findLeftMostNodes(tempCurrentNode, nodeDictionary);							return;						}						if (nodeTypeArray[index] == QuadTreeNode.O_TL)						{							tempCurrentNode = tempCurrentNode.mTL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_TR)						{							tempCurrentNode = tempCurrentNode.mTR;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BL)						{							tempCurrentNode = tempCurrentNode.mBL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BR)						{							tempCurrentNode = tempCurrentNode.mBR;						}					}					findLeftMostNodes(tempCurrentNode, nodeDictionary);				}			}			else			{				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_TR )				{					nodeTypeArray.push(QuadTreeNode.O_TL);				}				else if (node.mOrientation == QuadTreeNode.O_BL ||						 node.mOrientation == QuadTreeNode.O_BR)				{					nodeTypeArray.push(QuadTreeNode.O_BL);				}				if (node.mParent != null)				{					findRightAdjacentNode(node.mParent, nodeDictionary, nodeTypeArray);				}			}		}				private function findTopAdjacentNode(node:QuadTreeNode, nodeDictionary:Dictionary, nodeTypeArray:Array)		{			if (node.mOrientation == QuadTreeNode.O_BL)			{				if (node.mParent != null)				{					var tempCurrentNode:QuadTreeNode = node.mParent.mTL;					for (var index:int = nodeTypeArray.length-1; index >= 0; index--)					{						if (tempCurrentNode.mTL == null)						{							findBottomMostNodes(tempCurrentNode, nodeDictionary);							return;						}						if (nodeTypeArray[index] == QuadTreeNode.O_TL)						{							tempCurrentNode = tempCurrentNode.mTL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_TR)						{							tempCurrentNode = tempCurrentNode.mTR;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BL)						{							tempCurrentNode = tempCurrentNode.mBL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BR)						{							tempCurrentNode = tempCurrentNode.mBR;						}					}					findBottomMostNodes(tempCurrentNode, nodeDictionary);				}			}			else if (node.mOrientation == QuadTreeNode.O_BR)			{				if (node.mParent != null)				{					var tempCurrentNode:QuadTreeNode = node.mParent.mTR;					for (var index:int = nodeTypeArray.length-1; index >= 0; index--)					{						if (tempCurrentNode.mTL == null)						{							findBottomMostNodes(tempCurrentNode, nodeDictionary);							return;						}						if (nodeTypeArray[index] == QuadTreeNode.O_TL)						{							tempCurrentNode = tempCurrentNode.mTL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_TR)						{							tempCurrentNode = tempCurrentNode.mTR;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BL)						{							tempCurrentNode = tempCurrentNode.mBL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BR)						{							tempCurrentNode = tempCurrentNode.mBR;						}					}					findBottomMostNodes(tempCurrentNode, nodeDictionary);				}			}			else			{				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_BL )				{					nodeTypeArray.push(QuadTreeNode.O_BL);				}				else if (node.mOrientation == QuadTreeNode.O_TR ||						 node.mOrientation == QuadTreeNode.O_BR)				{					nodeTypeArray.push(QuadTreeNode.O_BR);				}				if (node.mParent != null)				{					findTopAdjacentNode(node.mParent, nodeDictionary, nodeTypeArray);				}			}		}				private function findBottomAdjacentNode(node:QuadTreeNode, nodeDictionary:Dictionary, nodeTypeArray:Array)		{			if (node.mOrientation == QuadTreeNode.O_TL)			{				if (node.mParent != null)				{					var tempCurrentNode:QuadTreeNode = node.mParent.mBL;					for (var index:int = nodeTypeArray.length-1; index >= 0; index--)					{						if (tempCurrentNode.mTL == null)						{							findTopMostNodes(tempCurrentNode, nodeDictionary);							return;						}						if (nodeTypeArray[index] == QuadTreeNode.O_TL)						{							tempCurrentNode = tempCurrentNode.mTL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_TR)						{							tempCurrentNode = tempCurrentNode.mTR;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BL)						{							tempCurrentNode = tempCurrentNode.mBL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BR)						{							tempCurrentNode = tempCurrentNode.mBR;						}					}					findTopMostNodes(tempCurrentNode, nodeDictionary);				}			}			else if (node.mOrientation == QuadTreeNode.O_TR)			{				if (node.mParent != null)				{					var tempCurrentNode:QuadTreeNode = node.mParent.mBR;					for (var index:int = nodeTypeArray.length-1; index >= 0; index--)					{						if (tempCurrentNode.mTL == null)						{							findTopMostNodes(tempCurrentNode, nodeDictionary);							return;						}						if (nodeTypeArray[index] == QuadTreeNode.O_TL)						{							tempCurrentNode = tempCurrentNode.mTL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_TR)						{							tempCurrentNode = tempCurrentNode.mTR;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BL)						{							tempCurrentNode = tempCurrentNode.mBL;						}						else if (nodeTypeArray[index] == QuadTreeNode.O_BR)						{							tempCurrentNode = tempCurrentNode.mBR;						}					}					findTopMostNodes(tempCurrentNode, nodeDictionary);				}			}			else			{				if (node.mOrientation == QuadTreeNode.O_TL ||					node.mOrientation == QuadTreeNode.O_BL )				{					nodeTypeArray.push(QuadTreeNode.O_TL);				}				else if (node.mOrientation == QuadTreeNode.O_TR ||						 node.mOrientation == QuadTreeNode.O_BR)				{					nodeTypeArray.push(QuadTreeNode.O_TR);				}				if (node.mParent != null)				{					findBottomAdjacentNode(node.mParent, nodeDictionary, nodeTypeArray);				}			}		}				private function drawNode(node:QuadTreeNode)		{			if (getChildByName("node") != null)			{				removeChild(getChildByName("node"));			}						var tempMovieClip:MovieClip = new MovieClip();			tempMovieClip.name = "node";			var rectangle:Shape = new Shape();			rectangle.graphics.beginFill(0x00FF00);			rectangle.graphics.drawRect(node.mX, node.mY, node.mWidth, node.mHeight);			rectangle.graphics.endFill();			rectangle.alpha = 0.5;			tempMovieClip.addChild(rectangle);			addChild(tempMovieClip);		}				private function drawHidingPointNodes(nodeDictionary:Dictionary):MovieClip		{			if (getChildByName("hidingPointNodes") != null)			{				removeChild(getChildByName("hidingPointNodes"));			}						var tempMovieClip:MovieClip = new MovieClip();						for (var tempNodeName:String in nodeDictionary)			{				var node:QuadTreeNode = nodeDictionary[tempNodeName];				var rectangle:Shape = new Shape();				if (node.mHidingOrientation == QuadTreeNode.HO_LEFT)				{					rectangle.graphics.beginFill(0x00FFFF);				}				else if (node.mHidingOrientation == QuadTreeNode.HO_RIGHT)				{					rectangle.graphics.beginFill(0x33FF33);				}				else if (node.mHidingOrientation == QuadTreeNode.HO_TOP)				{					rectangle.graphics.beginFill(0x660066);				}				else if (node.mHidingOrientation == QuadTreeNode.HO_BOTTOM)				{					rectangle.graphics.beginFill(0xFF3399);				}								rectangle.graphics.drawRect(node.mX, node.mY, node.mWidth, node.mHeight);				rectangle.graphics.endFill();				rectangle.alpha = 0.5;				tempMovieClip.addChild(rectangle);			}			return tempMovieClip;		}				public static function dicLength(myDictionary:Dictionary):int 		{			var n:int = 0;			for (var key:* in myDictionary)			{				n++;			}			return n;		}	}}